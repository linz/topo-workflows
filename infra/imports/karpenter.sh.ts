// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * NodePool is the Schema for the NodePools API
 *
 * @schema NodePool
 */
export class NodePool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NodePool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'karpenter.sh/v1',
    kind: 'NodePool',
  }

  /**
   * Renders a Kubernetes manifest for "NodePool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodePoolProps): any {
    return {
      ...NodePool.GVK,
      ...toJson_NodePoolProps(props),
    };
  }

  /**
   * Defines a "NodePool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodePoolProps) {
    super(scope, id, {
      ...NodePool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NodePool.GVK,
      ...toJson_NodePoolProps(resolved),
    };
  }
}

/**
 * NodePool is the Schema for the NodePools API
 *
 * @schema NodePool
 */
export interface NodePoolProps {
  /**
   * @schema NodePool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodePoolSpec is the top level nodepool specification. Nodepools
   * launch nodes in response to pods that are unschedulable. A single nodepool
   * is capable of managing a diverse set of nodes. Node properties are determined
   * from a combination of nodepool and pod scheduling constraints.
   *
   * @schema NodePool#spec
   */
  readonly spec: NodePoolSpec;

}

/**
 * Converts an object of type 'NodePoolProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolProps(obj: NodePoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodePoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodePoolSpec is the top level nodepool specification. Nodepools
 * launch nodes in response to pods that are unschedulable. A single nodepool
 * is capable of managing a diverse set of nodes. Node properties are determined
 * from a combination of nodepool and pod scheduling constraints.
 *
 * @schema NodePoolSpec
 */
export interface NodePoolSpec {
  /**
   * Disruption contains the parameters that relate to Karpenter's disruption logic
   *
   * @schema NodePoolSpec#disruption
   */
  readonly disruption?: NodePoolSpecDisruption;

  /**
   * Limits define a set of bounds for provisioning capacity.
   *
   * @schema NodePoolSpec#limits
   */
  readonly limits?: { [key: string]: NodePoolSpecLimits };

  /**
   * Template contains the template of possibilities for the provisioning logic to launch a NodeClaim with.
   * NodeClaims launched from this NodePool will often be further constrained than the template specifies.
   *
   * @schema NodePoolSpec#template
   */
  readonly template: NodePoolSpecTemplate;

  /**
   * Weight is the priority given to the nodepool during scheduling. A higher
   * numerical weight indicates that this nodepool will be ordered
   * ahead of other nodepools with lower weights. A nodepool with no weight
   * will be treated as if it is a nodepool with a weight of 0.
   *
   * @schema NodePoolSpec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'NodePoolSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpec(obj: NodePoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disruption': toJson_NodePoolSpecDisruption(obj.disruption),
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'template': toJson_NodePoolSpecTemplate(obj.template),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Disruption contains the parameters that relate to Karpenter's disruption logic
 *
 * @schema NodePoolSpecDisruption
 */
export interface NodePoolSpecDisruption {
  /**
   * Budgets is a list of Budgets.
   * If there are multiple active budgets, Karpenter uses
   * the most restrictive value. If left undefined,
   * this will default to one budget with a value to 10%.
   *
   * @schema NodePoolSpecDisruption#budgets
   */
  readonly budgets?: NodePoolSpecDisruptionBudgets[];

  /**
   * ConsolidateAfter is the duration the controller will wait
   * before attempting to terminate nodes that are underutilized.
   * Refer to ConsolidationPolicy for how underutilization is considered.
   *
   * @schema NodePoolSpecDisruption#consolidateAfter
   */
  readonly consolidateAfter: string;

  /**
   * ConsolidationPolicy describes which nodes Karpenter can disrupt through its consolidation
   * algorithm. This policy defaults to "WhenEmptyOrUnderutilized" if not specified
   *
   * @schema NodePoolSpecDisruption#consolidationPolicy
   */
  readonly consolidationPolicy?: NodePoolSpecDisruptionConsolidationPolicy;

}

/**
 * Converts an object of type 'NodePoolSpecDisruption' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecDisruption(obj: NodePoolSpecDisruption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'budgets': obj.budgets?.map(y => toJson_NodePoolSpecDisruptionBudgets(y)),
    'consolidateAfter': obj.consolidateAfter,
    'consolidationPolicy': obj.consolidationPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema NodePoolSpecLimits
 */
export class NodePoolSpecLimits {
  public static fromNumber(value: number): NodePoolSpecLimits {
    return new NodePoolSpecLimits(value);
  }
  public static fromString(value: string): NodePoolSpecLimits {
    return new NodePoolSpecLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Template contains the template of possibilities for the provisioning logic to launch a NodeClaim with.
 * NodeClaims launched from this NodePool will often be further constrained than the template specifies.
 *
 * @schema NodePoolSpecTemplate
 */
export interface NodePoolSpecTemplate {
  /**
   * @schema NodePoolSpecTemplate#metadata
   */
  readonly metadata?: NodePoolSpecTemplateMetadata;

  /**
   * NodeClaimTemplateSpec describes the desired state of the NodeClaim in the Nodepool
   * NodeClaimTemplateSpec is used in the NodePool's NodeClaimTemplate, with the resource requests omitted since
   * users are not able to set resource requests in the NodePool.
   *
   * @schema NodePoolSpecTemplate#spec
   */
  readonly spec: NodePoolSpecTemplateSpec;

}

/**
 * Converts an object of type 'NodePoolSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplate(obj: NodePoolSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_NodePoolSpecTemplateMetadata(obj.metadata),
    'spec': toJson_NodePoolSpecTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Budget defines when Karpenter will restrict the
 * number of Node Claims that can be terminating simultaneously.
 *
 * @schema NodePoolSpecDisruptionBudgets
 */
export interface NodePoolSpecDisruptionBudgets {
  /**
   * Duration determines how long a Budget is active since each Schedule hit.
   * Only minutes and hours are accepted, as cron does not work in seconds.
   * If omitted, the budget is always active.
   * This is required if Schedule is set.
   * This regex has an optional 0s at the end since the duration.String() always adds
   * a 0s at the end.
   *
   * @schema NodePoolSpecDisruptionBudgets#duration
   */
  readonly duration?: string;

  /**
   * Nodes dictates the maximum number of NodeClaims owned by this NodePool
   * that can be terminating at once. This is calculated by counting nodes that
   * have a deletion timestamp set, or are actively being deleted by Karpenter.
   * This field is required when specifying a budget.
   * This cannot be of type intstr.IntOrString since kubebuilder doesn't support pattern
   * checking for int nodes for IntOrString nodes.
   * Ref: https://github.com/kubernetes-sigs/controller-tools/blob/55efe4be40394a288216dab63156b0a64fb82929/pkg/crd/markers/validation.go#L379-L388
   *
   * @schema NodePoolSpecDisruptionBudgets#nodes
   */
  readonly nodes: string;

  /**
   * Reasons is a list of disruption methods that this budget applies to. If Reasons is not set, this budget applies to all methods.
   * Otherwise, this will apply to each reason defined.
   * allowed reasons are Underutilized, Empty, and Drifted.
   *
   * @schema NodePoolSpecDisruptionBudgets#reasons
   */
  readonly reasons?: NodePoolSpecDisruptionBudgetsReasons[];

  /**
   * Schedule specifies when a budget begins being active, following
   * the upstream cronjob syntax. If omitted, the budget is always active.
   * Timezones are not supported.
   * This field is required if Duration is set.
   *
   * @schema NodePoolSpecDisruptionBudgets#schedule
   */
  readonly schedule?: string;

}

/**
 * Converts an object of type 'NodePoolSpecDisruptionBudgets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecDisruptionBudgets(obj: NodePoolSpecDisruptionBudgets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'nodes': obj.nodes,
    'reasons': obj.reasons?.map(y => y),
    'schedule': obj.schedule,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ConsolidationPolicy describes which nodes Karpenter can disrupt through its consolidation
 * algorithm. This policy defaults to "WhenEmptyOrUnderutilized" if not specified
 *
 * @schema NodePoolSpecDisruptionConsolidationPolicy
 */
export enum NodePoolSpecDisruptionConsolidationPolicy {
  /** WhenEmpty */
  WHEN_EMPTY = "WhenEmpty",
  /** WhenEmptyOrUnderutilized */
  WHEN_EMPTY_OR_UNDERUTILIZED = "WhenEmptyOrUnderutilized",
}

/**
 * @schema NodePoolSpecTemplateMetadata
 */
export interface NodePoolSpecTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be
   * set by external tools to store and retrieve arbitrary metadata. They are not
   * queryable and should be preserved when modifying objects.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
   *
   * @schema NodePoolSpecTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Map of string keys and values that can be used to organize and categorize
   * (scope and select) objects. May match selectors of replication controllers
   * and services.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
   *
   * @schema NodePoolSpecTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'NodePoolSpecTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplateMetadata(obj: NodePoolSpecTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * NodeClaimTemplateSpec describes the desired state of the NodeClaim in the Nodepool
 * NodeClaimTemplateSpec is used in the NodePool's NodeClaimTemplate, with the resource requests omitted since
 * users are not able to set resource requests in the NodePool.
 *
 * @schema NodePoolSpecTemplateSpec
 */
export interface NodePoolSpecTemplateSpec {
  /**
   * ExpireAfter is the duration the controller will wait
   * before terminating a node, measured from when the node is created. This
   * is useful to implement features like eventually consistent node upgrade,
   * memory leak protection, and disruption testing.
   *
   * @schema NodePoolSpecTemplateSpec#expireAfter
   */
  readonly expireAfter?: string;

  /**
   * NodeClassRef is a reference to an object that defines provider specific configuration
   *
   * @schema NodePoolSpecTemplateSpec#nodeClassRef
   */
  readonly nodeClassRef: NodePoolSpecTemplateSpecNodeClassRef;

  /**
   * Requirements are layered with GetLabels and applied to every node.
   *
   * @schema NodePoolSpecTemplateSpec#requirements
   */
  readonly requirements: NodePoolSpecTemplateSpecRequirements[];

  /**
   * StartupTaints are taints that are applied to nodes upon startup which are expected to be removed automatically
   * within a short period of time, typically by a DaemonSet that tolerates the taint. These are commonly used by
   * daemonsets to allow initialization and enforce startup ordering.  StartupTaints are ignored for provisioning
   * purposes in that pods are not required to tolerate a StartupTaint in order to have nodes provisioned for them.
   *
   * @schema NodePoolSpecTemplateSpec#startupTaints
   */
  readonly startupTaints?: NodePoolSpecTemplateSpecStartupTaints[];

  /**
   * Taints will be applied to the NodeClaim's node.
   *
   * @schema NodePoolSpecTemplateSpec#taints
   */
  readonly taints?: NodePoolSpecTemplateSpecTaints[];

  /**
   * TerminationGracePeriod is the maximum duration the controller will wait before forcefully deleting the pods on a node, measured from when deletion is first initiated.
   *
   * Warning: this feature takes precedence over a Pod's terminationGracePeriodSeconds value, and bypasses any blocked PDBs or the karpenter.sh/do-not-disrupt annotation.
   *
   * This field is intended to be used by cluster administrators to enforce that nodes can be cycled within a given time period.
   * When set, drifted nodes will begin draining even if there are pods blocking eviction. Draining will respect PDBs and the do-not-disrupt annotation until the TGP is reached.
   *
   * Karpenter will preemptively delete pods so their terminationGracePeriodSeconds align with the node's terminationGracePeriod.
   * If a pod would be terminated without being granted its full terminationGracePeriodSeconds prior to the node timeout,
   * that pod will be deleted at T = node timeout - pod terminationGracePeriodSeconds.
   *
   * The feature can also be used to allow maximum time limits for long-running jobs which can delay node termination with preStop hooks.
   * If left undefined, the controller will wait indefinitely for pods to be drained.
   *
   * @schema NodePoolSpecTemplateSpec#terminationGracePeriod
   */
  readonly terminationGracePeriod?: string;

}

/**
 * Converts an object of type 'NodePoolSpecTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplateSpec(obj: NodePoolSpecTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expireAfter': obj.expireAfter,
    'nodeClassRef': toJson_NodePoolSpecTemplateSpecNodeClassRef(obj.nodeClassRef),
    'requirements': obj.requirements?.map(y => toJson_NodePoolSpecTemplateSpecRequirements(y)),
    'startupTaints': obj.startupTaints?.map(y => toJson_NodePoolSpecTemplateSpecStartupTaints(y)),
    'taints': obj.taints?.map(y => toJson_NodePoolSpecTemplateSpecTaints(y)),
    'terminationGracePeriod': obj.terminationGracePeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DisruptionReason defines valid reasons for disruption budgets.
 *
 * @schema NodePoolSpecDisruptionBudgetsReasons
 */
export enum NodePoolSpecDisruptionBudgetsReasons {
  /** Underutilized */
  UNDERUTILIZED = "Underutilized",
  /** Empty */
  EMPTY = "Empty",
  /** Drifted */
  DRIFTED = "Drifted",
}

/**
 * NodeClassRef is a reference to an object that defines provider specific configuration
 *
 * @schema NodePoolSpecTemplateSpecNodeClassRef
 */
export interface NodePoolSpecTemplateSpecNodeClassRef {
  /**
   * API version of the referent
   *
   * @schema NodePoolSpecTemplateSpecNodeClassRef#group
   */
  readonly group: string;

  /**
   * Kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
   *
   * @schema NodePoolSpecTemplateSpecNodeClassRef#kind
   */
  readonly kind: string;

  /**
   * Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema NodePoolSpecTemplateSpecNodeClassRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NodePoolSpecTemplateSpecNodeClassRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplateSpecNodeClassRef(obj: NodePoolSpecTemplateSpecNodeClassRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A node selector requirement with min values is a selector that contains values, a key, an operator that relates the key and values
 * and minValues that represent the requirement to have at least that many values.
 *
 * @schema NodePoolSpecTemplateSpecRequirements
 */
export interface NodePoolSpecTemplateSpecRequirements {
  /**
   * The label key that the selector applies to.
   *
   * @schema NodePoolSpecTemplateSpecRequirements#key
   */
  readonly key: string;

  /**
   * This field is ALPHA and can be dropped or replaced at any time
   * MinValues is the minimum number of unique values required to define the flexibility of the specific requirement.
   *
   * @schema NodePoolSpecTemplateSpecRequirements#minValues
   */
  readonly minValues?: number;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema NodePoolSpecTemplateSpecRequirements#operator
   */
  readonly operator: NodePoolSpecTemplateSpecRequirementsOperator;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   *
   * @schema NodePoolSpecTemplateSpecRequirements#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'NodePoolSpecTemplateSpecRequirements' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplateSpecRequirements(obj: NodePoolSpecTemplateSpecRequirements | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'minValues': obj.minValues,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The node this Taint is attached to has the "effect" on
 * any pod that does not tolerate the Taint.
 *
 * @schema NodePoolSpecTemplateSpecStartupTaints
 */
export interface NodePoolSpecTemplateSpecStartupTaints {
  /**
   * Required. The effect of the taint on pods
   * that do not tolerate the taint.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema NodePoolSpecTemplateSpecStartupTaints#effect
   */
  readonly effect: NodePoolSpecTemplateSpecStartupTaintsEffect;

  /**
   * Required. The taint key to be applied to a node.
   *
   * @schema NodePoolSpecTemplateSpecStartupTaints#key
   */
  readonly key: string;

  /**
   * TimeAdded represents the time at which the taint was added.
   * It is only written for NoExecute taints.
   *
   * @schema NodePoolSpecTemplateSpecStartupTaints#timeAdded
   */
  readonly timeAdded?: Date;

  /**
   * The taint value corresponding to the taint key.
   *
   * @schema NodePoolSpecTemplateSpecStartupTaints#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodePoolSpecTemplateSpecStartupTaints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplateSpecStartupTaints(obj: NodePoolSpecTemplateSpecStartupTaints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'timeAdded': obj.timeAdded?.toISOString(),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The node this Taint is attached to has the "effect" on
 * any pod that does not tolerate the Taint.
 *
 * @schema NodePoolSpecTemplateSpecTaints
 */
export interface NodePoolSpecTemplateSpecTaints {
  /**
   * Required. The effect of the taint on pods
   * that do not tolerate the taint.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema NodePoolSpecTemplateSpecTaints#effect
   */
  readonly effect: NodePoolSpecTemplateSpecTaintsEffect;

  /**
   * Required. The taint key to be applied to a node.
   *
   * @schema NodePoolSpecTemplateSpecTaints#key
   */
  readonly key: string;

  /**
   * TimeAdded represents the time at which the taint was added.
   * It is only written for NoExecute taints.
   *
   * @schema NodePoolSpecTemplateSpecTaints#timeAdded
   */
  readonly timeAdded?: Date;

  /**
   * The taint value corresponding to the taint key.
   *
   * @schema NodePoolSpecTemplateSpecTaints#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'NodePoolSpecTemplateSpecTaints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_NodePoolSpecTemplateSpecTaints(obj: NodePoolSpecTemplateSpecTaints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'timeAdded': obj.timeAdded?.toISOString(),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Represents a key's relationship to a set of values.
 * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
 *
 * @schema NodePoolSpecTemplateSpecRequirementsOperator
 */
export enum NodePoolSpecTemplateSpecRequirementsOperator {
  /** In */
  IN = "In",
  /** NotIn */
  NOT_IN = "NotIn",
  /** Exists */
  EXISTS = "Exists",
  /** DoesNotExist */
  DOES_NOT_EXIST = "DoesNotExist",
  /** Gt */
  GT = "Gt",
  /** Lt */
  LT = "Lt",
}

/**
 * Required. The effect of the taint on pods
 * that do not tolerate the taint.
 * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
 *
 * @schema NodePoolSpecTemplateSpecStartupTaintsEffect
 */
export enum NodePoolSpecTemplateSpecStartupTaintsEffect {
  /** NoSchedule */
  NO_SCHEDULE = "NoSchedule",
  /** PreferNoSchedule */
  PREFER_NO_SCHEDULE = "PreferNoSchedule",
  /** NoExecute */
  NO_EXECUTE = "NoExecute",
}

/**
 * Required. The effect of the taint on pods
 * that do not tolerate the taint.
 * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
 *
 * @schema NodePoolSpecTemplateSpecTaintsEffect
 */
export enum NodePoolSpecTemplateSpecTaintsEffect {
  /** NoSchedule */
  NO_SCHEDULE = "NoSchedule",
  /** PreferNoSchedule */
  PREFER_NO_SCHEDULE = "PreferNoSchedule",
  /** NoExecute */
  NO_EXECUTE = "NoExecute",
}

